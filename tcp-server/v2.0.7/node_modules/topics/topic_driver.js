

const Fn = require('../utilities/fn-utilities').Fn;
const Tp = require('./topic_common').Tp;
var IOCOMMON = require('../iostreams/iocommon');
var KIO = IOCOMMON.KIO;

var IOStream = require('../iostreams/iostream').IOStream;
var IOServer = require('../iostreams/ioserver').IOServer;
var TopicPath = require('./topic_path').TopicPath;

/**
 * Driver for Topic based connections.
 * @returns {TopicDriver}
 */
class TopicDriver {
  constructor() {
    /**
     * Connection with remote control or server.<br>
     * Used to made a bridge connection ...
     * @type {IOStream}
     */
    this.remoteSocket;
    /**
     * Local server used.
     * @type {IOServer}
     */
    this.localServer;
    /**
     * Devices List
     * @type {Array}
     */
    this.devices = {};
    /**
     * Topic List
     * @type {Array}
     */
    this.topics = {};
    Fn.extends(this, arguments[0]);
    return this;
  }
  /**
   * <b>TopicDriver</b> Gets attached connections count.
   * @returns {Number}
   */
  getDevicesCount() {
    return Fn.lengthOf(this.devices);
  }
  /**
   * <b>TopicDriver</b> Accepts or no the specified device.
   * @param {IOStream} device   Who sends the event
   * @param {Object} request    Connection request
   * @returns {Boolean} true if devices was accepted.
   */
  addDevice(device, request) {
    let driver = this;
    if (!device || !request) return false;
    let deviceId = Tp.getDeviceId(request);
    if (deviceId.length > 0) {
      /** @type {IOStream} */
      let previous = driver.getDevice(deviceId);
      if (previous) {
        driver.removeDevice(previous);
        if (previous != device) {
          previous.close({
            'action': 'disconnect',
            'reason': KIO.name_exist,
            'message': 'Name exists'
          });
          previous.name = "!" + previous.name;
        }
      }
      driver.devices[deviceId] = device;
      device.name = deviceId;
      device.type = Tp.getDeviceType(request);
      device.lineEnd = Tp.getDeviceLineEnd(request);
      device.echoDisabled = Tp.getDeviceEcho(request);
      device.keepAlive = Tp.getDeviceKeepAlive(request);
      device.protocol = Tp.getProtocol(request);
      device.version = Tp.getVersion(request);
      device.username = Tp.getUserName(request);
      device.password = Tp.getPassword(request);
      device.topics = {};
      device.send({
        'action': 'conack',
        'device_id': deviceId,
        'device_type': device.type,
        'ip': device.getAddress()
      });
      device.setIOState(KIO.attached);
      //...................................................
      let trequest = request.topic || request.topics;
      if (trequest) {
        driver.subscribeRequest(device, trequest);
      }
      return true;
    }
    //.....................................................
    device.close({
      'action': 'disconnect',
      'reason': KIO.bad_protocol,
      'message': 'Bad Protocol'
    });
    return false;
  }
  /**
   * Gets a device from the driver.
   * @param {Object} request Gets request
   * @returns {IOStream} The Device or null if not found.
   */
  getDevice(request) {
    let driver = this;
    let dname = Tp.getDeviceId(request);
    /** @type {IOStream} */
    let device = driver.devices[dname];
    return device;
  }
  /**
   * Removes a device from the driver.
   * @param {Object} request Remove request
   * @returns {Boolean} true if device was removed.
   */
  removeDevice(request) {
    let driver = this;
    let dname = Tp.getDeviceId(request);
    /** @type {IOStream} */
    let scket = driver.devices[dname];
    if (scket) {
      if (scket.topics) {
        for (let k in scket.topics) {
          /** @type {TopicPath} */
          let topic = driver.getTopic(scket.topics[k]);
          if (topic) topic.removeDevice(scket);
        }
      }
      delete (driver.devices[dname]);
      return true;
    }
    return false;
  }
  /**
   * Adds a new topic to the driver.
   * @param {Object} request
   * @returns {TopicPath} Topic or null if error
   */
  addTopic(request) {
    let driver = this;
    /** @type {TopicPath} */
    let topic;
    let tname = Tp.getRealTopicName(request);
    if (tname.length > 0) {
      topic = driver.topics[tname];
      if (!topic) {
        topic = new TopicPath({
          'driver': driver,
          'name': tname
        });
        driver.topics[tname] = topic;
      }
    }
    return topic;
  }
  /**
   * Gets topic from the driver.
   * @param {Object} request Gets request
   * @returns {TopicPath} Topic or null if not found
   */
  getTopic(request) {
    let driver = this;
    let tname = Tp.getRealTopicName(request);
    /** @type {TopicPath} */
    let topic = driver.topics[tname];
    return topic;
  }
  /**
   * Removes a device from the driver.
   * @param {type} request Remove request
   * @returns {Boolean} true if was removed.
   */
  removeTopic(request) {
    let driver = this;
    let tname = Tp.getRealTopicName(request);
    /** @type {TopicPath} */
    let topic = driver.topics[tname];
    if (topic) {
      delete (driver.topics[tname]);
      return true;
    }
    return false;
  }
  /**
   * <b>TopicDriver</b> Launch Device Topic Subscribed Event
   * @param {IOStream} device   The sender
   * @param {String} topicName  The Topic's name
   * @returns {TopicDriver}
   */
  topicAdded(device, topicName) {
    let driver = this;
    driver.sendToLeft(device, topicName, {
      'action': 'subscribe',
      'topic': topicName,
      'id': device.getName(),
      'ip': device.getAddress()
    });
    driver.sendToMonitor(device, {
      'action': 'subscribe',
      'topic': topicName,
      'id': device.getName(),
      'ip': device.getAddress()
    });
    return driver;
  }
  /**
   * <b>TopicDriver</b> Launch Device Topic Removed Event
   * @param {IOStream} device   The sender
   * @param {String} topicName  The Topic's name
   * @returns {TopicDriver}
   */
  topicRemoved(device, topicName) {
    let driver = this;
    driver.sendToLeft(device, topicName, {
      'action': 'unsubscribe',
      'topic': topicName,
      'id': device.getName(),
      'ip': device.getAddress()
    });
    driver.sendToMonitor(device, {
      'action': 'unsubscribe',
      'topic': topicName,
      'id': device.getName(),
      'ip': device.getAddress()
    });
    return driver;
  }
  /**
   * <b>TopicDriver</b> Gets Client that can listen the specified Topic.
   * @param {String} topicName The Topic's name
   * @returns {Array|Object} Client at the left to specified topic
   */
  getLeftDevices(topicName) {
    let driver = this;
    let clist = {};
    while (topicName.length > 0) {
      topicName = Tp.nextLeft(topicName);
      if (topicName.length > 0) {
        /** @type {TopicPath} */
        let topic = driver.topics[topicName];
        if (topic) {
          for (let k in topic.devices) {
            clist[k] = topic.name;
          }
        }
      }
    }
    return clist;
  }
  /**
   * <b>TopicDriver</b> Send to Devices at topic left side.
   * @param {IOStream} device   The Sender
   * @param {String} topicName  Topic's name
   * @param {Object} message    The message
   * @returns {TopicDriver}
   */
  sendToLeft(device, topicName, message) {
    let driver = this;
    let clist = driver.getLeftDevices(topicName);
    for (let k in clist) {
      /** @type {IOStream} */
      let remote = driver.getDevice(k);
      if (remote && remote !== device) {
        let tname = Tp.deviceTopicName(remote, clist[k]);
        if (tname.length > 0) {
          remote.send({
            'action': 'publish',
            'topic': tname,
            'data': message
          });
        }
      }
    }
    return driver;
  }
  /**
   * <b>TopicDriver</b> Informs to Monitor about Process flow
   * @param {IOStream} device   The sender
   * @param {Object} message    The message
   * @returns {TopicDriver}
   */
  sendToMonitor(device, message) {
    let driver = this;
    let topicName = './monitor';
    /** @type {TopicPath} */
    let topic = driver.getTopic(topicName);
    if (topic) {
      let ndevices = Fn.parseToArray(topic.devices);
      for (let k in ndevices) {
        /** @type {IOStream} */
        let monitor = topic.devices[ndevices[k]];
        if (monitor && monitor != device) {
          monitor.send({
            'action': 'publish',
            'topic': topicName,
            'data': message
          });
        }
      }
    }
    return driver;
  }
  /**
   * Subscription Request
   * @param {IOStream} device The sender
   * @param {Object} request  The subscriotion request
   */
  subscribeRequest(device, request) {
    let driver = this;
    let trequest = Fn.isArray(request)
      ? request
      : request.topics
        ? request.topics
        : Tp.getTopicName(request);
    if (Fn.isString(trequest)) trequest = [trequest];
    if (!Fn.isArray(trequest)) return driver;
    for (let i0 = 0; i0 < trequest.length; i0++) {
      let item = trequest[i0];
      /** @type TopicPath */
      let topic = driver.addTopic(item);
      if (!topic) continue;
      topic.addDevice(device, item);
      let tname = Tp.deviceTopicName(device, topic.name);
      if (tname.length < 1) continue;
      device.send({
        'action': 'suback',
        'topic': tname
      });
    }
    return driver;
  }
  /**
   * <b>TopicDriver</b> Device Subscription Request
   * @param {IOStream} device 
   * @param {Object} request 
   */
  unsubscribeRequest(device, request) {
    let driver = this;
    let trequest = Fn.isArray(request)
      ? request
      : request.topics
        ? request.topics
        : Tp.getTopicName(request);
    if (Fn.isString(trequest)) trequest = [trequest];
    if (!Fn.isArray(trequest)) return driver;
    for (let i0 = 0; i0 < trequest.length; i0++) {
      let item = trequest[i0];
      /** @type TopicPath */
      let topic = driver.getTopic(item);
      if (!topic) continue;
      let tname = Tp.deviceTopicName(device, topic.name);
      topic.removeDevice(device, item);
      if (tname.length < 1) continue;
      device.send({
        'action': 'unsuback',
        'topic': tname
      });
    }
    return driver;
  }
  /**
   * Message received
   * @param {IOStream} device The senser
   * @param {Object} request  The request
   */
  publishRecieved(device, request) {
    let driver = this;
    /** @type {TopicPath} */
    let topic = driver.addTopic(request);
    if (topic) {
      let message = Tp.getRequestData(request);
      topic.distribute(device, message);
      message = {
        'data': message,
        'action': 'publish',
        'topic': topic.name,
        'id': device.getName(),
        'ip': device.getAddress()
      };
      driver.sendToLeft(device, topic.name, message);
      driver.sendToMonitor(device, message);
    }
  }
  /**
   * Message acknowledge
   * @param {IOStream} device The senser
   * @param {Object} request  The request
   */
  publishAcknowledge(device, request) {
    let driver = this;
    return driver;
  }
  /**
   * Message Timeout
   * @param {IOStream} device The senser
   * @param {Object} request  The request
   */
  publishTimeout(device, request) {
    let driver = this;
    return driver;
  }
  /**
   * Ping request
   * @param {IOStream} device The sensder
   * @param {Object} request  The request 
   */
  pingRequest(device, request) {
    let driver = this;
    return driver;
  }
  /**
   * Ping response
   * @param {IOStream} device The sensder
   * @param {Object} request  The request 
   */
  pingResponse(device, request) {
    let driver = this;
    return driver;
  }
  /**
   * Bridged was closed event
   * @param {IOStream} device The sensder
   * @param {Object} request  The request 
   */
  bridgeClosed(device, request) {
    let driver = this;
    return driver;
  }
  /**
   * Command request from device
   * @param {IOStream} device The sensder
   * @param {Object} request  The request 
   */
  deviceCommand(device, request) {
    let driver = this;
    return driver;
  }
  /**
   * Device reception attention
   * @param {IOStream} device 
   * @param {Object} request 
   */
  deviceReception(device, request) {
    if (!device || !request) return;
    let driver = this;
    if (!device.isAttached()) {
      switch (request.action) {
        case 'connect':
          driver.addDevice(device, request);
          break;
        case 'disconnect':
          device.close();
          break;
        case 'bridge.closed':
          driver.bridgeClosed(device, request);
          break;
      }
      return;
    }
    switch (request.action) {
      case 'connect':
        driver.addDevice(device, request);
        break;

      case 'disconnect':
        device.close();
        break;

      case 'subscribe':
        driver.subscribeRequest(device, request);
        break;

      case 'unsubscribe':
        driver.unsubscribeRequest(device, request);
        break;

      case 'publish':
        driver.publishRecieved(device, request);
        break;

      case 'acknowledge':
        driver.publishAcknowledge(device, request);
        break;

      case 'timeout':
        driver.publishTimeout(device, request);
        break;

      case 'ping':
      case 'ping.request':
        driver.pingRequest(device, request);
        break;

      case 'ping.response':
        driver.pingResponse(device, request);
        break;

      case 'bridge.closed':
        driver.bridgeClosed(device, request);
        break;

      default:
        driver.deviceCommand(device, request);
        break;
    }
  }
}

module.exports = {
  TopicDriver
};
