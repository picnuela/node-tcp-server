
const Fn = require('../utilities/fn-utilities').Fn;
var IOCOMMON = require('./iocommon');
var KIO = IOCOMMON.KIO;

var IOStream = require('./iostream').IOStream;
var NET = require('net');

class IOServer {
  constructor() {
    /** <b>IOServer</b> server Connection
     * @type {NET.Server}   */
    this.tserver;
    /** <b>IOServer</b> Server Address
     * @type {String}       */
    this.host = "";
    /** <b>IOServer</b> Server Listening Port
     * @type {Number}       */
    this.port = 0;
    /** <b>IOServer</b> Connection Type Flag
     * @type {Boolean}       */
    this.isServer = true;
    /** <b>IOServer</b> Server Address
     * @type {String}       */
    this.address = "";
    /** <b>IOServer</b> Server Name
     * @type {String}       */
    this.name = "";
    /** <b>IOServer</b> Alive time in seconds
     * @type {Number}       */
    this.keepAlive = 0;
    /** <b>IOServer</b> Attached Client List
     * @type {Object}       */
    this.children = {};
    /** <b>IOServer</b> Server State
     * @type {String}      */
    this.iostate = KIO.closed;
    /** <b>IOServer</b> Internal Interval ID
     * @type {String}       */
    this.timerId = 0;
    /** <b>IOServer</b> Client Event Listener
     * @type {IOListener}   */
    this.clientListener;
    /** <b>IOServer</b> Client Reception Event
     * @type {Function}     */
    this.ondata;
    /** <b>IOServer</b> Server Open Event
     * @type {Function}     */
    this.onchange;
    /** <b>IOServer</b> Server Error Event
     * @type {Function}     */
    this.onerror;
    /** <b>IOServer</b> Control loop function
     * @type {Function}     */
    this.looper;

    Fn.extends(this, arguments[0]);
    return this;
  }
  /**
   * Informs some error
   * @param {Object} err
   * @returns {IOServer}
   */
  setError(err) {
    let server = this;
    if (Fn.isFunction(server.onerror)) {
      server.onerror(err, server);
    }
    return server;
  }
  /**
   * Checks for Stream Status
   * @returns {Boolean} true if Stream is closed.
   */
  isClosed() {
    let sta = this.iostate;
    return sta == KIO.closed;
  }
  /**
   * Checks for Stream Status
   * @returns {Boolean} true if Stream is connected.
   */
  isOpen() {
    let sta = this.iostate;
    return sta == KIO.connected || sta == KIO.attached;
  }
  /**
   * Sets a new Connection State for this Stream.
   * @param {Number} state
   * @returns {IOServer}
   */
  setIOState(state) {
    let server = this;
    if (server.iostate != state) {
      let last = server.iostate;
      server.iostate = state;
      if (Fn.isFunction(server.onchange)) {
        server.onchange(server, state, last);
      }
    }
    return server;
  }
  /**
   * Close Stream Request
   * @returns {IOServer}
   */
  close() {
    let server = this;
    if ((server.iostate == KIO.closing) ||
      (server.iostate == KIO.close_request)) {
      return server;
    }
    server.setIOState(KIO.closing);
    //-----------------------------------------------------
    if (server.timerId) {
      clearInterval(server.timerId);
      server.timerId = 0;
    }
    //-----------------------------------------------------
    let cnames = Fn.parseToArray(server.children);
    for (let k in cnames) {
      /** @type {IOStream}  */
      let client = server.children[cnames[k]];
      if (client)
        client.close({
          'action': 'disconnect',
          'reason': KIO.server_shutdown,
          'message': 'Server shutdown'
        });
    }
    //-----------------------------------------------------
    if (server.tserver) {
      try {
        if (Fn.isFunction(server.tserver.destroy)) {
          server.tserver.destroy();
        } else if (Fn.isFunction(server.tserver.close)) {
          server.tserver.close();
        }
      } catch (e) {
      }
      server.tserver = undefined;
    }
    server.setIOState(KIO.closed);
    return server;
  }
  /**
   * Stream Opens/Starts Request
   * @param {Object} options Defines <b>host</b> and <b>port</b> parameters
   * @returns {IOServer}
   */
  listen(options) {
    let io = this;
    return io;
  }
  /**
   * Gets Stream Assigned Name/Identity
   * @returns {String}
   */
  getName() {
    return this.name;
  }
  /**
   * Gets Stream Assigned Address
   * @returns {String}
   */
  getAddress() {
    return this.address;
  }
  /**
   * Gets children Connection
   * @param {String} address
   * @returns {IOServer} Children Connection or null if not found
   */
  getClient(address) {
    /** @type {IOServer} */
    let stream = this.children[address];
    return stream;
  }
  /**
   * Gets How many Client attached to this Stream
   * @returns {Number}
   */
  getClientsCount() {
    return Fn.lengthOf(this.children);
  }
}

module.exports = {
  IOServer
};
