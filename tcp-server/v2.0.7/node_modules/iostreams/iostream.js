
const Fn = require('../utilities/fn-utilities').Fn;
var IOCOMMON = require('./iocommon');
var KIO = IOCOMMON.KIO;

/**
 * Class to instance Stream
 */
class IOStream {
  constructor() {
    /** Object that wraps me (this Object)
     * @type {IOStream}   */
    this.parent;
    /** Stream associated to this Object
     * @type {IOStream}   */
    this.stream;
    /** <b>IOStream</b> Checks if Stream was made from a Server.
     * @type {Boolean}    */
    this.isServer = false;
    /** <b>IOStream</b> Assigned Name
     * @type {String}     */
    this.name = "";
    /** <b>IOStream</b> Assigned Address
     * @type {String}     */
    this.address = "";
    /** <b>IOStream</b> Transmission Line ended.
     * @type {String}     */
    this.lineEnd = "";
    /** <b>IOStream</b> Device Echo property.
     * @type {Boolean}     */
    this.echoDisabled = false;
    /** <b>IOStream</b> Stream protocol.
     * @type {String}     */
    this.protocol = "json";
    /** <b>IOStream</b> Device Type Name.
     * @type {String}     */
    this.type = "";
    /** <b>IOStream</b> Current connection State
     * @type {Number}     */
    this.iostate = 0;
    /** <b>IOStream</b> Keep Alive Time in seconds
     * @type {Number}     */
    this.keepAlive = 0;
    /** <b>IOStream</b> Secure level.<br>
     * It is defined into connect phase.
     * @type {Number}     */
    this.secureLevel = 0;
    /** <b>IOStream</b> Security password.
     * @type {String}     */
    this.password = "";
    /** <b>IOStream</b> User/Group name.
     * @type {String}     */
    this.username = "";
    /** <b>IOStream</b> Object version.
     * @type {String}     */
    this.version = "";
    /** <b>IOStream</b> Reception timestamp
     * @type {Number}     */
    this.lastRead = Fn.millis();
    /** <b>IOStream</b> Transmission timestamp
     * @type {Number}     */
    this.lastWrite = Fn.millis();
    /** <b>IOStream</b> Connection/Created timestamp
     * @type {Number}     */
    this.createdAt = Fn.millis();
    /** <b>IOStream</b> Internal Interval ID.
     * @type {Number}     */
    this.timerId = 0;
    /** <b>IOStream</b> Instance Connections from this Stream.
     * @type {Array}      */
    this.children = {};
    /** <b>IOStream</b> Frame Receptor for this Stream.
     * @type {IOReceptor} */
    this.receptor;
    /** <b>IOStream</b> Client Event Listener
     * @type {IOListener}   */
    this.clientListener;
    /** <b>IOStream</b> Connection Changed Event CallBack
     * @type {Function}   */
    this.onchange;
    /** <b>IOStream</b> Reception Event CallBack
     * @type {Function}   */
    this.ondata;
    /** <b>IOStream</b> Reception Event CallBack
     * @type {Function}   */
    this.onerror;
    /** <b>IOStream</b> Application function for Alive Request
     * @type {Function}   */
    this.onAliveRequest;
    /** <b>IOStream</b> Application function for Alive Response
     * @type {Function}   */
    this.onAliveResponse;
    /** <b>IOServer</b> Control loop function
     * @type {Function}     */
    this.looper;

    Fn.extends(this, arguments[0]);
    return this;
  }
  /**
   * Creates a Bridge Connection request.
   * @param {String} ipaddress
   * @returns {IOStream|undefined}
   */
  createBridge(ipaddress) {
    /** @type {IOStream}  */
    let bridge;
    return bridge;
  }
  /**
   * Informs some error
   * @param {Object} err
   * @returns {IOStream}
   */
  setError(err) {
    let io = this;
    if (Fn.isFunction(io.onerror)) {
      io.onerror(err, io);
    }
    return io;
  }
  /**
   * Checks for Stream Status
   * @returns {Boolean} true if Stream is attached.
   */
  isAttached() {
    let sta = this.iostate;
    return sta == KIO.attached;
  }
  /**
   * Checks for Stream Status
   * @returns {Boolean} true if Stream is closed.
   */
  isClosed() {
    let sta = this.iostate;
    return sta == KIO.closed;
  }
  /**
   * Checks for Stream Status
   * @returns {Boolean} true if Stream is connected.
   */
  isOpen() {
    let sta = this.iostate;
    return sta == KIO.connected ||
      sta == KIO.attached ||
      sta == KIO.closing;
  }
  /**
   * Sets a new Connection State for this Stream.
   * @param {Number} state
   * @returns {IOStream}
   */
  setIOState(state) {
    let io = this;
    if (io.iostate != state) {
      let last = io.iostate;
      io.iostate = state;
      if (Fn.isFunction(io.onchange)) {
        io.onchange(io, state, last);
      }
    }
    return io;
  }
  /**
   * Close Stream Request
   * @param {String|Number|Object} reason
   * @returns {IOStream}
   */
  close(reason) {
    let io = this;
    return closeStream(io, reason);
  }
  /**
   * Send Stream Data
   * @param {String|Object} data
   * @returns {IOStream}
   */
  send(data) {
    let io = this;
    if (!io.isOpen()) return io;
    if (io.stream) {
      if (!data) return io;
      if (Fn.isJSON(data)) data = Fn.asString(data);
      if (Fn.isString(data)) data += io.lineEnd;
      try {
        if (Fn.isFunction(io.stream.write)) {
          io.stream.write(data);
        } else if (Fn.isFunction(io.stream.send)) {
          io.stream.send(data);
        }
      } catch (e) {
        io.setError(e);
      }
    }
    return io;
  }
  /**
   * Stream Opens/Starts Request
   * @returns {IOStream}
   */
  open() {
    let io = this;
    return io;
  }
  /**
   * Gets Stream Assigned Name/Identity
   * @returns {String}
   */
  getName() {
    return this.name;
  }
  /**
   * Gets Stream Assigned Address
   * @returns {String}
   */
  getAddress() {
    return this.address;
  }
  /**
   * Gets children Connection
   * @param {String} address
   * @returns {IOStream} Children Connection or null if not found
   */
  getClient(address) {
    /** @type {IOStream} */
    let stream = this.children[address];
    return stream;
  }
  /**
   * Gets How many Client attached to this Stream
   * @returns {Number}
   */
  getClientsCount() {
    return Fn.lengthOf(this.children);
  }
  /**
   * Checks for Connection and Frame Timeouts.
   * @returns {IOStream}
   */
  checksAlive() {
    let ta, tm, t0, t1;
    //................................................
    let io = this;
    if (!io.isOpen()) {
      tm = Fn.millis();
      t0 = tm - io.createdAt;
      if (t0 > KIO.closeDelay) {
        io.createdAt = tm;
        if (io.timerId) {
          clearInterval(io.timerId);
          io.timerId = 0;
        }
        if (io.parent && io.parent.children) {
          delete (io.parent.children[io.address]);
        }
        io.setIOState(KIO.closed);
      }
      return io;
    }
    //..................................................
    let clist = Fn.parseToArray(io.children);
    for (let k in clist) {
      /** @type {IOStream}  */
      let bridge = io.children[clist[k]];
      if (bridge) bridge.checksAlive();
    }
    //..................................................
    /** @type {IOReceptor} */
    let receptor = io.receptor;
    if (receptor && receptor.onFrame) {
      ta = receptor.frameTimeout;
      if (ta > 1) {
        tm = Fn.millis();
        t0 = tm - receptor.lastRead;
        if (t0 > ta) {
          receptor.onFrame = false;
          let text = receptor.rxString;
          text = Fn.trim(text);
          if (text.length > 0) {
            io.setError("Frame timeout");
            receptor.launch();
          }
          receptor.clear();
        }
      }
    }
    //................................................
    tm = KIO.maxKeepAlive;
    if (tm < 1) tm = 300;
    if (tm > 3600) tm = 3600;
    ta = io.keepAlive;
    if (ta < 1) ta = tm;
    if (ta > tm) ta = tm;
    //..................................................
    let issocket = Fn.isFunction(io.onAliveRequest);
    if (issocket) {
      tm = Fn.millis();
      t0 = tm - io.lastWrite;
      t1 = ta * 350;
      if (t0 > t1) {
        io.lastWrite = tm;
        io.onAliveRequest(io);
      }
    }
    tm = Fn.millis();
    t0 = tm - io.lastRead;
    t1 = ta * 1250;
    if (t0 > t1) {
      io.lastRead = tm;
      let ecode = issocket
        ? KIO.server_timeout
        : KIO.socket_timeout;
      let reason = issocket
        ? "Server timeout"
        : "Socket timeout";
      io.setError(reason);
      io.close({
        'action': 'disconnect',
        'reason': ecode,
        'message': reason
      });
    }
    return io;
  }
}
/**
 * Close Stream Request
 * @param {IOStream} io
 * @param {Object} reason
 * @returns {IOStream}
 */
function closeStream(io, reason) {
  if ((io.iostate == KIO.close_request) ||
  (io.iostate == KIO.closed) ||
    (io.iostate == KIO.closing)) {
    return io;
  }
  io.createdAt = Fn.millis();
  io.setIOState(KIO.closing);
  //.....................................................
  let cnames = Fn.parseToArray(io.children);
  for (let k in cnames) {
    /** @type {IOStream} */
    let bridge = io.children[cnames[k]];
    if (bridge) {
      bridge.close(reason
        ? reason
        : KIO.defaultClose);
    }
  }
  //.....................................................  
  if (io.stream) {
    io.send(reason);
    try {
      if (Fn.isFunction(io.stream.destroy)) {
        io.stream.destroy();
      } else if (Fn.isFunction(io.stream.close)) {
        if (io.stream !== io.parent) {
          io.stream.close();
        }
      }
    } catch (e) {
    }
    io.stream = undefined;
  }
  //.....................................................
  if (io.timerId) {
    clearInterval(io.timerId);
    io.timerId = 0;
  }
  //.....................................................
  if (io.parent && io.parent.children) {
    delete (io.parent.children[io.address]);
  }
  //.....................................................
  io.setIOState(KIO.closed);
  return io;
}

module.exports = {
  IOStream,
  closeStream
};
