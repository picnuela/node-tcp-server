
/* global IOStream */

const Fn = require('../utilities/fn-utilities').Fn;
var IOCOMMON = require('./iocommon');
var KIO = IOCOMMON.KIO;

var IOStream = require('./iostream').IOStream;
var IOReceptor = require('./ioreceptor').IOReceptor;
var IOBridge = require('./iobridge').IOBridge;
var NET = require('net');

/**
 * Bridged Stream into a IOSocket
 * @returns {IOSocket}
 */
class IOSocket extends IOStream {
  /**
   * Stream Opens/Starts Request
   * @param {Object} options Define <b>"host"</b> and <b>"port"</b> properties.
   * @returns {IOStream}
   */
  open(options) {
    return _iosocketOpen(this, options);
  }
  /**
   * Stream Opens/Starts Request
   * @param {Object} options Define <b>"host"</b> and <b>"port"</b> properties.
   * @returns {IOStream}
   */
  connect(options) {
    return _iosocketOpen(this, options);
  }
  /**
   * Creates a Bridge Connection request.
   * @param {String} ipaddress
   * @returns {IOStream}
   */
  createBridge(ipaddress) {
    return _iosocketCreateBridge(this, ipaddress);
  }
}
/**
 * @param {IOStream} io
 * @param {String} ipaddress
 * @returns {IOStream}
 */
function _iosocketCreateBridge(io, ipaddress) {
    /** @type {IOStream}  */
  let bridge;
   let boptions = Fn.extends({
    'address': ipaddress,
    'parent': io,
    'stream': io,
    'ondata': io.ondata,
    'onchange': io.onchange,
    'onerror': io.onerror,
    /**
     * @param {IOStream} scket
     */
    'onAliveRequest': function(scket) {
      scket.send("~\r\n");
    }
  }, io.clientListener);
  bridge = new IOBridge(boptions);
  bridge.open();
  return bridge;
}
/**
 * @param {IOStream} io
 * @param {Object} options
 * @returns {IOStream}
 */
function _iosocketOpen(io, options) {
  options = Fn.extends({
    'host': io.host,
    'port': io.port
  }, options);
  //...................................................
  if (!io.receptor) {
    io.receptor = new IOReceptor({
      parent: io,
      isServer: false,
      /**
       * @param {Object} data
       * @param {IOStream} scket
       */
      oncomplete: function (data, scket) {
        if (!data || !scket) {
          return;
        }
        if (Fn.isFunction(scket.ondata)) {
          scket.ondata(data, scket);
        }
      }
    });
  }
  //...................................................
  if (!io.onAliveRequest) {
    /**
     * @param {IOStream} scket
     */
    io.onAliveRequest = function (scket) {
      scket.lastWrite = Fn.millis();
      scket.send("~\r\n");
    };
  }
  //...................................................
  io.stream = new NET.Socket({
    'allowHalfOpen': true
  });
  //
  io.stream.on("data", function (data) {
    io.lastRead = Fn.millis();
    /** @type {IOReceptor} */
    let receptor = io.receptor;
    if (receptor) {
      receptor.receive(data);
      return true;
    }
    if (Fn.isFunction(io.ondata)) {
      io.ondata(data, io);
    }
    return true;
  });
  //
  io.stream.on("close", function () {
    io.stream = undefined;
    io.close();
  });
  //
  io.stream.on("end", function () {
    io.stream = undefined;
    io.close();
  });
  //
  io.stream.on("error", function (err) {
    if (Fn.isFunction(io.onerror)) {
      io.onerror(err, io);
    }
  });
  //
  io.stream.connect({
    port: Fn.asNumber(options.port),
    host: options.host

  }, function () {
    let ipa = io.stream.address();
    if (ipa) ipa = ipa.address + ":" + ipa.port;
    if (ipa) io.address = ipa;
    if (io.parent && io.parent.children) {
      io.parent.children[io.address] = io;
    }
    //--------------------------------------------
    let tm = Fn.millis();
    io.lastRead = tm;
    io.lastWrite = tm;
    io.createdAt = tm;
    io.setIOState(KIO.connected);
    //--------------------------------------------
    // Creates Interval
    //
    io.timerId = setInterval(function () {
      io.checksAlive();
    }, 250);
    return true;
  });
  //
  return io;
}

module.exports = {
  IOSocket
};
